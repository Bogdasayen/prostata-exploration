/**
 * @file
 * @author  Mark Clements <mark.clements@ki.se>
 * @version 1.0
 *
 * @section LICENSE
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details at
 * http://www.gnu.org/copyleft/gpl.html
 *
 * @section DESCRIPTION 

 Microsimulation of prostate cancer using the FHCRC model.

 TODO
 * other causes of death - incorporate rates
 * other transitions
 * age-specific reporting of state probabilities
*/

#include "event-r.h"
#include <Rcpp.h>

using namespace std;

namespace Hutch
{

//! enum for type of Gleason score
enum gleason_t {nogleason,gleasonLt7,gleason7,gleasonGt7};

//! enum of type of disease stage
enum stage_t {Healthy,Localised,DxLocalised,LocallyAdvanced,DxLocallyAdvanced,
	      Metastatic,DxMetastatic,Death};

//! enum of type of event type
enum event_t {toDeath, toPCDeath, toLocalised, toDxLocalised,
	      toDxLocallyAdvanced,
	      toLocallyAdvanced, toMetastatic, toDxMetastatic};

//! Class to simulate a person
class Person : public cProcess 
{
public:
  gleason_t gleason;
  stage_t stage;
  bool dx;
  Time previousTime;
  
  // static members (for statistics)
  static vector<stage_t> stages;
  static vector<Time> startTimes, endTimes;
  static vector<event_t> events;

  static void resetPopulation ();
  //
  Person() : dx(false), gleason(nogleason), stage(Healthy) {};
  void init();
  virtual void handleMessage(const cMessage* msg);
  virtual Time age() { return now(); }
};

void Person::resetPopulation() {
  stages.clear();
  startTimes.clear();
  endTimes.clear();
  events.clear();
}


/** Hazard ratio for diagnosis
    @param stage Disease stage
 */
double dxHR(stage_t stage) {
  // raise error if healthy?
  return stage==Healthy ? -1 : 
    (stage==Localised ? 1.1308 : 
     (stage==LocallyAdvanced ? 0.5900 :1.3147));
}

/** Hazard ratio for progression
    @param gleason Gleason category
 */
double progressionHR(gleason_t gleason) {
  return gleason==gleasonLt7 ? 1 :
      (gleason==gleason7 ? 1.3874 : 1.4027 * 1.3874);
}

/** 
    Initialise a simulation run for an individual
 */
void Person::init() {
  previousTime = 0.0;
  if (R::runif(0.0,1.0)<0.2241) 
    scheduleAt(R::rweibull(exp(2.3525),64.0218),toLocalised);
  scheduleAt(R::rexp(80.0),toDeath);
}

/** 
    Handle receiving self-messages
 */
void Person::handleMessage(const cMessage* msg) {

  double dwellTime, pDx;

  startTimes.push_back(previousTime);
  endTimes.push_back(now());
  stages.push_back(stage);
  events.push_back((event_t) msg->kind);

  if (msg->kind == toDeath) {
    Sim::stop_simulation();
  }
 
  else if (msg->kind == toPCDeath) {
    Sim::stop_simulation(); 
  }
  
  else if (msg->kind == toLocalised) {
    stage = Localised;
    gleason = (R::runif(0.0,1.0)<0.6812) ? gleasonLt7 : 
      ((R::runif(0.0,1.0)<0.5016) ? gleason7 : gleasonGt7);
    Time dwellTime = now()+
      rweibullHR(exp(1.0353),19.8617,progressionHR(gleason)*
	       dxHR(stage));
    // now separate out for different transitions
    pDx = 1.1308/(2.1308);
    if (R::runif(0.0,1.0)<pDx) {
      scheduleAt(dwellTime, toDxLocalised);
    }
    else {
      scheduleAt(dwellTime,toLocallyAdvanced);
    }
  }
  
  else if (msg->kind == toLocallyAdvanced) {
    stage=LocallyAdvanced;
    Time dwellTime = now()+
      rweibullHR(exp(1.4404),16.3863,progressionHR(gleason)*
	       dxHR(stage));
    // now separate out for different transitions
    pDx = 0.5900/(1.0+0.5900);
    if (R::runif(0.0,1.0)<pDx) {
      scheduleAt(dwellTime, toDxLocallyAdvanced);
    }
    else {
      scheduleAt(dwellTime,toMetastatic);
    }
  }

  else if (msg->kind == toMetastatic) {
    stage=Metastatic;
    Time dwellTime = now()+
      rweibullHR(exp(1.4404),1.4242,progressionHR(gleason)*
	       dxHR(stage));
    // now separate out for different transitions
    pDx = 1.3147/(1.0+1.3147); 
    if (R::runif(0.0,1.0)<pDx) {
      scheduleAt(dwellTime, toDxMetastatic);
    }
    else {
      scheduleAt(dwellTime,toPCDeath); // prior to diagnosis!
    }
  }

  else if (msg->kind == toDxLocalised) {
    dx=true;
    // relative survival
  }

  else if (msg->kind == toDxLocallyAdvanced) {
    dx=true;
    // relative survival
  }

  else if (msg->kind == toDxMetastatic) {
    dx=true;
    // relative survival
  };
  
  previousTime = now();

};

} // namespace Hutch

extern "C" {

RcppExport SEXP callPersonSimulation2(SEXP inseed, SEXP parms) {
  Rcpp::List parmsl(parms);
  Rcpp::IntegerVector inseed2(inseed);
  int nin = Rcpp::as<int>(parmsl["n"]);
  unsigned long seed[6];
    for (int i=0; i<6; i++) {
      seed[i]=(unsigned long)inseed2[i];
    }
    RngStream_SetPackageSeed(seed);
    Rng * rng = new Rng();
    rng->set();
    Hutch::Person person;
    Hutch::Person::resetPopulation();
    for (int i = 0; i < nin; i++) {
      rng->nextSubstream();
      person = Hutch::Person();
      Sim::create_process(&person);
      Sim::run_simulation();
      Sim::clear();
    }
    // tidy up -- what needs to be deleted?
    delete rng;
    // output arguments to R
    return Rcpp::wrap<int>(1);
  }


} // extern "C"

